"""
Error report persistence for task failures.

Generates and writes error reports in markdown format to queue/errors directory.
"""

import os
import logging
from pathlib import Path
from datetime import datetime

try:
    from orchestration.core.models import TaskRecord
except ImportError:
    from core.models import TaskRecord

logger = logging.getLogger(__name__)


def generate_error_report(
    task_record: TaskRecord,
    stage: str,
    command: str,
    exit_code: int,
    stdout: str,
    stderr: str,
) -> str:
    """
    Generate a detailed error report in markdown format.

    Includes task metadata, failure details, and suggested retry action.

    Args:
        task_record: TaskRecord for the failed task.
        stage: Stage where failure occurred (planning, building, etc).
        command: Command that failed (e.g., "make-plan").
        exit_code: Exit code from failed command (-1 for timeout).
        stdout: Standard output from command.
        stderr: Standard error from command.

    Returns:
        Markdown-formatted error report as string.
    """
    timestamp = datetime.utcnow().isoformat()

    # Truncate long output
    stdout_preview = stdout[:500] if stdout else "(empty)"
    stderr_preview = stderr[:500] if stderr else "(empty)"

    report = f"""# Task Failure Report

**Timestamp**: {timestamp}

## Task Metadata

- **Task ID**: {task_record.id}
- **Repository**: {task_record.repo}
- **Base Branch**: {task_record.base}
- **Task File**: {task_record.task_file}
- **Attempt**: {task_record.attempt}
- **Session ID**: {task_record.session_id}

## Failure Details

**Stage**: {stage}  
**Command**: `{command}`  
**Exit Code**: {exit_code}

### Standard Output

```
{stdout_preview}
```

### Standard Error

```
{stderr_preview}
```

## Runtime Context

- **Branch**: {task_record.branch}
- **Worktree**: {task_record.worktree_path}
- **Container**: {task_record.container}
- **Port**: {task_record.port}

## Suggested Actions

1. Check the error output above for specific failure reasons
2. Review task file: `{task_record.task_file}`
3. Inspect worktree if still available: `{task_record.worktree_path}`
4. Increment attempt counter and retry with `claim_first_todo()`

---

*Generated by worker pipeline*
"""
    return report


def write_error_report(
    error_report: str,
    task_id: str,
    errors_dir: str | None = None,
) -> Path:
    """
    Write error report to file in queue/errors directory.

    Uses task_id and timestamp to ensure unique filename.

    Args:
        error_report: Markdown content to write.
        task_id: Task identifier for filename.
        errors_dir: Directory to write to (default: queue/errors).

    Returns:
        Path to written error file.

    Raises:
        OSError: If write fails.
    """
    if errors_dir is None:
        errors_dir = os.path.join(
            os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
            "queue",
            "errors",
        )

    # Ensure directory exists
    Path(errors_dir).mkdir(parents=True, exist_ok=True)

    # Generate unique filename with timestamp
    timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S_%f")[:19]  # YYYYMMDD_HHMMSS
    filename = f"{task_id}-{timestamp}.md"
    error_path = Path(errors_dir) / filename

    try:
        error_path.write_text(error_report, encoding="utf-8")
        logger.info(f"Error report written to {error_path}")
        return error_path
    except IOError as e:
        logger.error(f"Failed to write error report: {e}")
        raise
